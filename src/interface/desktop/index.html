<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khoj Mini</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        #styled-input {
            width: 100%;
            font-size: 14px;
            height: 100px;
            min-height: 50px;
            background-color: #475569; /* Blue background */
            color: #dcdfe4;              /* White text */
            font-family: 'Inter', sans-serif;
            border: none;
            resize: vertical;
        }
        .chat-input {
            margin-top: 10px;
            position: fixed;
            bottom: 0;
            left: 5;
            width: 100%;
            max-width: 600px;
            display: flex;
            padding-top: 10px;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
        }
        #input-container {
            background-color: #475569;
            border-radius: 5px;
            padding: 10px;
        }
        #send-button {
            border: none;
            border-radius: 5px 5px 5px 5px;
            margin-top: 5px;
            background-color: #5a6b84;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            font-family: 'Inter', sans-serif;
            font-weight: bold;
            position: relative;
        }
        #send-button:hover {
            text-decoration: underline;
            background: #7489a9;
        }

        ::-webkit-scrollbar {
        width: 5px; /* Width of the scrollbar */
        height: 5px;
        }
        /* * {
        outline: 1px solid rgb(255, 255, 255);
        } */

        /* Track */
        ::-webkit-scrollbar-track {
        background: #f1f1f1; /* Background of the scrollbar track */
        border-radius: 10px;
        }

        /* Handle */
        ::-webkit-scrollbar-thumb {
        background: #2d2d2d; /* Color of the scrollbar thumb */
        border-radius: 10px;
        }

        /* Handle on hover */
        ::-webkit-scrollbar-thumb:hover {
        background: #000000; /* Color of the scrollbar thumb on hover */
        }

        #copy-icon {
            width: 20px;
            height: 20px;
            margin-right: 5px;
        }
        /* CSS for the container */
        .logo-container {
            /* display: flex; Use flexbox to align items */
            align-items: center; /* Align items vertically */
            justify-content: flex;
        }

        /* CSS for the image */
        img {
            width: 100px; /* Set the desired width */
            height: auto; /* Allows the image to scale proportionally */
        }
        .clipboardText {
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            background-color: #475569;
            color: #dcdfe4;
            padding: 10px;
            border-radius: 5px;
            width: 100%;
            word-wrap: break-word;
        }
        #chat-body {
            width: 100%;
            font-family: 'Inter', sans-serif;
            word-wrap: break-word;
            line-height: 20px;
        }
        b {
            font-size: 14px;
            font-family: 'Inter', sans-serif;
        }
        h1 {
            font-size: 20px;
            font-family: 'Inter', sans-serif;
            text-align: center;
        }
        body {
            background-color: #f9f5de;
            padding-top: 10px;
            font-family:'Inter', sans-serif;
            font-weight: 400;
            scrollbar-width: 5px; /* "auto" or "thin" */
            scrollbar-color: #000000 #f1f1f1; /* thumb color and track color */
            height: 300px;
            overflow: scroll;
        }
        #chat-body-wrapper {
            padding-left: 10px;
            padding-right: 10px;
        }

    </style>
</head>
<body>
    <!-- Container for the logo and the phrase -->
    <div class="logo-container">
        <!-- Logo -->
        <img src="assets\icons\khoj-logo-sideways.svg"></img>
    </div>
    <div id="chat-body-wrapper">
        <!-- <div id="clipboardText"></div> -->
        <div id="input-container">
            <textarea id="styled-input" name="styled-input">Hello World!</textarea>
            <script>
                console.log("attempting clipboard extraction...")
                try {
                    if (!window.clipboardAPI) {
                        throw new Error('clipboardAPI is not available');
                    }

                    window.clipboardAPI.sendClipboardText((clipboardText) => {
                        try {
                        const styledInput = document.getElementById('styled-input');
                        if (!styledInput) {
                            throw new Error('styled-input element not found');
                        }
                        styledInput.value = clipboardText;
                        console.log("success: ", clipboardText);
                        } catch (error) {
                        console.error('Error handling clipboard text:', error);
                        }
                    });
                    } catch (error) {
                    console.error('Error setting up clipboard listener:', error);
                    }
            </script>
            <button id="send-button">
                Send
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-send">
                    <path d="M5 12l10 0-5-5m5 5-5 5" />
                </svg>
            </button>
        </div>
        <div id="chat-body"></div>
    </div>
    <script src="main.js"></script>
    <script type="text/javascript" src="./assets/purify.min.js?v={{ khoj_version }}"></script>
    <script type="text/javascript" src="./assets/markdown-it.min.js"></script>
    <script src="./utils.js"></script>
    <script>

        let region = null;
        let city = null;
        let countryName = null;
        let timezone = null;

        fetch("https://ipapi.co/json")
            .then(response => response.json())
            .then(data => {
                region = data.region;
                city = data.city;
                countryName = data.country_name;
                timezone = data.timezone;
            })
            .catch(err => {
                console.log(err);
                return;
            });

        function copyParentText(event, message=null) {
            const button = event.currentTarget;
            const textContent = message ?? button.parentNode.textContent.trim();
            navigator.clipboard.writeText(textContent).then(() => {
                button.firstChild.src = "./assets/icons/copy-button-success.svg";
                setTimeout(() => {
                    button.firstChild.src = "./assets/icons/copy-button.svg";
                }, 1000);
            }).catch((error) => {
                console.error("Error copying text to clipboard:", error);
                const originalButtonText = button.innerHTML;
                button.innerHTML = "⛔️";
                setTimeout(() => {
                    button.innerHTML = originalButtonText;
                    button.firstChild.src = "./assets/icons/copy-button.svg";
                }, 2000);
            });
        }

        function createCopyParentText(message) {
            return function(event) {
                copyParentText(event, message);
            }
        }
        function formatDate(date) {
            // Format date in HH:MM, DD MMM YYYY format
            let time_string = date.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', hour12: false });
            let date_string = date.toLocaleString('en-IN', { year: 'numeric', month: 'short', day: '2-digit'}).replaceAll('-', ' ');
            return `${time_string}, ${date_string}`;
        }

        function generateReference(referenceJson, index) {
            let reference = referenceJson.hasOwnProperty("compiled") ? referenceJson.compiled : referenceJson;
            let referenceFile = referenceJson.hasOwnProperty("file") ? referenceJson.file : null;

            // Escape reference for HTML rendering
            let escaped_ref = reference.replaceAll('"', '&quot;');

            // Generate HTML for Chat Reference
            let short_ref = escaped_ref.slice(0, 100);
            short_ref = short_ref.length < escaped_ref.length ? short_ref + "..." : short_ref;
            let referenceButton = document.createElement('button');
            referenceButton.textContent = short_ref;
            referenceButton.id = `ref-${index}`;
            referenceButton.classList.add("reference-button");
            referenceButton.classList.add("collapsed");
            referenceButton.tabIndex = 0;

            // Add event listener to toggle full reference on click
            referenceButton.addEventListener('click', function() {
                if (this.classList.contains("collapsed")) {
                    this.classList.remove("collapsed");
                    this.classList.add("expanded");
                    this.textContent = escaped_ref;
                } else {
                    this.classList.add("collapsed");
                    this.classList.remove("expanded");
                    this.textContent = short_ref;
                }
            });

            return referenceButton;
        }

        function generateOnlineReference(reference, index) {

            // Generate HTML for Chat Reference
            let title = reference.title || reference.link;
            let link = reference.link;
            let snippet = reference.snippet;
            let question = reference.question;
            if (question) {
                question = `<b>Question:</b> ${question}<br><br>`;
            } else {
                question = "";
            }

            let linkElement = document.createElement('a');
            linkElement.setAttribute('href', link);
            linkElement.setAttribute('target', '_blank');
            linkElement.setAttribute('rel', 'noopener noreferrer');
            linkElement.classList.add("inline-chat-link");
            linkElement.classList.add("reference-link");
            linkElement.setAttribute('title', title);
            linkElement.textContent = title;

            let referenceButton = document.createElement('button');
            referenceButton.innerHTML = linkElement.outerHTML;
            referenceButton.id = `ref-${index}`;
            referenceButton.classList.add("reference-button");
            referenceButton.classList.add("collapsed");
            referenceButton.tabIndex = 0;

            // Add event listener to toggle full reference on click
            referenceButton.addEventListener('click', function() {
                if (this.classList.contains("collapsed")) {
                    this.classList.remove("collapsed");
                    this.classList.add("expanded");
                    this.innerHTML = linkElement.outerHTML + `<br><br>${question + snippet}`;
                } else {
                    this.classList.add("collapsed");
                    this.classList.remove("expanded");
                    this.innerHTML = linkElement.outerHTML;
                }
            });

            return referenceButton;
        }

        function renderMessage(message, by, dt=null, annotations=null, raw=false, renderType="append") {
            let message_time = formatDate(dt ?? new Date());
            let by_name =  by == "khoj" ? "🏮 Khoj" : "🤔 You";
            let formattedMessage = formatHTMLMessage(message, raw);

            // Create a new div for the chat message
            let chatMessage = document.createElement('div');
            chatMessage.className = `chat-message ${by}`;
            chatMessage.dataset.meta = `${by_name} at ${message_time}`;

            // Create a new div for the chat message text and append it to the chat message
            let chatMessageText = document.createElement('div');
            chatMessageText.className = `chat-message-text ${by}`;
            chatMessageText.appendChild(formattedMessage);
            chatMessage.appendChild(chatMessageText);

            // Append annotations div to the chat message
            if (annotations) {
                chatMessageText.appendChild(annotations);
            }

            // Append chat message div to chat body
            let chatBody = document.getElementById("chat-body");
            if (renderType === "append") {
                chatBody.appendChild(chatMessage);
                // Scroll to bottom of chat-body element
                chatBody.scrollTop = chatBody.scrollHeight;
            } else if (renderType === "prepend") {
                chatBody.insertBefore(chatMessage, chatBody.firstChild);
            } else if (renderType === "return") {
                return chatMessage;
            }

            let chatBodyWrapper = document.getElementById("chat-body");
            chatBodyWrapperHeight = chatBodyWrapper.clientHeight;
            autoResize();
        }

        function processOnlineReferences(referenceSection, onlineContext) {
            let numOnlineReferences = 0;
            for (let subquery in onlineContext) {
                let onlineReference = onlineContext[subquery];
                if (onlineReference.organic && onlineReference.organic.length > 0) {
                    numOnlineReferences += onlineReference.organic.length;
                    for (let index in onlineReference.organic) {
                        let reference = onlineReference.organic[index];
                        let polishedReference = generateOnlineReference(reference, index);
                        referenceSection.appendChild(polishedReference);
                    }
                }

                if (onlineReference.knowledgeGraph && onlineReference.knowledgeGraph.length > 0) {
                    numOnlineReferences += onlineReference.knowledgeGraph.length;
                    for (let index in onlineReference.knowledgeGraph) {
                        let reference = onlineReference.knowledgeGraph[index];
                        let polishedReference = generateOnlineReference(reference, index);
                        referenceSection.appendChild(polishedReference);
                    }
                }

                if (onlineReference.peopleAlsoAsk && onlineReference.peopleAlsoAsk.length > 0) {
                    numOnlineReferences += onlineReference.peopleAlsoAsk.length;
                    for (let index in onlineReference.peopleAlsoAsk) {
                        let reference = onlineReference.peopleAlsoAsk[index];
                        let polishedReference = generateOnlineReference(reference, index);
                        referenceSection.appendChild(polishedReference);
                    }
                }

                if (onlineReference.webpages && onlineReference.webpages.length > 0) {
                    numOnlineReferences += onlineReference.webpages.length;
                    for (let index in onlineReference.webpages) {
                        let reference = onlineReference.webpages[index];
                        let polishedReference = generateOnlineReference(reference, index);
                        referenceSection.appendChild(polishedReference);
                    }
                }
            }

            return numOnlineReferences;
        }

        function renderMessageWithReference(message, by, context=null, dt=null, onlineContext=null, intentType=null, inferredQueries=null) {
            let chatEl;
            if (intentType?.includes("text-to-image")) {
                let imageMarkdown = generateImageMarkdown(message, intentType, inferredQueries);
                chatEl = renderMessage(imageMarkdown, by, dt, null, false, "return");
            } else {
                chatEl = renderMessage(message, by, dt, null, false, "return");
            }

            // If no document or online context is provided, render the message as is
            if ((context == null || context?.length == 0)
                && (onlineContext == null || (onlineContext && Object.keys(onlineContext).length == 0))) {
                return chatEl;
            }

            // If document or online context is provided, render the message with its references
            let references = {};
            if (!!context) references["notes"] = context;
            if (!!onlineContext) references["online"] = onlineContext;
            let chatMessageEl = chatEl.getElementsByClassName("chat-message-text")[0];
            chatMessageEl.appendChild(createReferenceSection(references));

            return chatEl;
        }

        function generateImageMarkdown(message, intentType, inferredQueries=null) {
            let imageMarkdown;
            if (intentType === "text-to-image") {
                imageMarkdown = `![](data:image/png;base64,${message})`;
            } else if (intentType === "text-to-image2") {
                imageMarkdown = `![](${message})`;
            } else if (intentType === "text-to-image-v3") {
                imageMarkdown = `![](data:image/webp;base64,${message})`;
            }
            const inferredQuery = inferredQueries?.[0];
            if (inferredQuery) {
                imageMarkdown += `\n\n**Inferred Query**:\n\n${inferredQuery}`;
            }
            return imageMarkdown;
        }

        function formatHTMLMessage(message, raw=false, willReplace=true) {
            var md = window.markdownit();
            let newHTML = message;

            // Remove any text between <s>[INST] and </s> tags. These are spurious instructions for the AI chat model.
            newHTML = newHTML.replace(/<s>\[INST\].+(<\/s>)?/g, '');

            // Customize the rendering of images
            md.renderer.rules.image = function(tokens, idx, options, env, self) {
                let token = tokens[idx];

                // Add class="text-to-image" to images
                token.attrPush(['class', 'text-to-image']);

                // Use the default renderer to render image markdown format
                return self.renderToken(tokens, idx, options);
            };

            // Render markdown
            newHTML = raw ? newHTML : md.render(newHTML);
            // Sanitize the rendered markdown
            newHTML = DOMPurify.sanitize(newHTML);
            // Set rendered markdown to HTML DOM element
            let element = document.createElement('div');
            element.innerHTML = newHTML;
            element.className = "chat-message-text-response";

            // Add a copy button to each chat message
            if (willReplace === true) {
                let copyButton = document.createElement('button');
                copyButton.classList.add("copy-button");
                copyButton.title = "Copy Message";
                let copyIcon = document.createElement("img");
                copyIcon.id = "copy-icon";
                copyIcon.src = "./assets/icons/copy-button.svg";
                copyIcon.classList.add("copy-icon");
                copyButton.appendChild(copyIcon);
                copyButton.addEventListener('click', createCopyParentText(message));
                element.append(copyButton);
            }

            // Get any elements with a class that starts with "language"
            let codeBlockElements = element.querySelectorAll('[class^="language-"]');
            // For each element, add a parent div with the class "programmatic-output"
            codeBlockElements.forEach((codeElement, key) => {
                // Create the parent div
                let parentDiv = document.createElement('div');
                parentDiv.classList.add("programmatic-output");
                // Add the parent div before the code element
                codeElement.parentNode.insertBefore(parentDiv, codeElement);
                // Move the code element into the parent div
                parentDiv.appendChild(codeElement);
                // Add a copy button to each element
            });

            // Get all code elements that have no class.
            let codeElements = element.querySelectorAll('code:not([class])');
            codeElements.forEach((codeElement) => {
                // Add the class "chat-response" to each element
                codeElement.classList.add("chat-response");
            });

            let anchorElements = element.querySelectorAll('a');
            anchorElements.forEach((anchorElement) => {
                // Tag external links to open in separate window
                if (
                    !anchorElement.href.startsWith("./") &&
                    !anchorElement.href.startsWith("#") &&
                    !anchorElement.href.startsWith("/")
                ) {
                    anchorElement.setAttribute('target', '_blank');
                    anchorElement.setAttribute('rel', 'noopener noreferrer');
                }

                // Add the class "inline-chat-link" to each element
                anchorElement.classList.add("inline-chat-link");
            });

            return element
        }

        function createReferenceSection(references) {
            let referenceSection = document.createElement('div');
            referenceSection.classList.add("reference-section");
            referenceSection.classList.add("collapsed");

            let numReferences = 0;

            if (references.hasOwnProperty("notes")) {
                numReferences += references["notes"].length;

                references["notes"].forEach((reference, index) => {
                    let polishedReference = generateReference(reference, index);
                    referenceSection.appendChild(polishedReference);
                });
            }
            if (references.hasOwnProperty("online")){
                numReferences += processOnlineReferences(referenceSection, references["online"]);
            }

            let referenceExpandButton = document.createElement('button');
            referenceExpandButton.classList.add("reference-expand-button");
            referenceExpandButton.innerHTML = numReferences == 1 ? "1 reference" : `${numReferences} references`;

            referenceExpandButton.addEventListener('click', function() {
                if (referenceSection.classList.contains("collapsed")) {
                    referenceSection.classList.remove("collapsed");
                    referenceSection.classList.add("expanded");
                } else {
                    referenceSection.classList.add("collapsed");
                    referenceSection.classList.remove("expanded");
                }
            });

            let referencesDiv = document.createElement('div');
            referencesDiv.classList.add("references");
            referencesDiv.appendChild(referenceExpandButton);
            referencesDiv.appendChild(referenceSection);

            return referencesDiv;
        }

        async function chat() {
            // Extract required fields for search from form
            let query = document.getElementById("styled-input");
            query = query.value;
            query.setAttribute('readonly', true);
            let resultsCount = localStorage.getItem("khojResultsCount") || 5;
            console.log(`Query: ${query}`);

            // Short circuit on empty query
            if (query.length === 0)
                return;

            let chat_body = document.getElementById("chat-body");

            let conversationID = chat_body.dataset.conversationId;
            let hostURL = await window.hostURLAPI.getURL();
            const khojToken = await window.tokenAPI.getToken();
            const headers = { 'Authorization': `Bearer ${khojToken}` };

            if (!conversationID) {
                let response = await fetch(`${hostURL}/api/chat/sessions`, { method: "POST", headers });
                let data = await response.json();
                conversationID = data.conversation_id;
                chat_body.dataset.conversationId = conversationID;
            }

            // Generate backend API URL to execute query
            let chatApi = `${hostURL}/api/chat?q=${encodeURIComponent(query)}&n=${resultsCount}&client=web&stream=true&conversation_id=${conversationID}&region=${region}&city=${city}&country=${countryName}&timezone=${timezone}`;

            let newResponseEl = document.createElement("div");
            newResponseEl.classList.add("chat-message", "khoj");
            newResponseEl.attributes["data-meta"] = "🏮 Khoj at " + formatDate(new Date());
            chat_body.appendChild(newResponseEl);

            let newResponseTextEl = document.createElement("div");
            newResponseTextEl.classList.add("chat-message-text", "khoj");
            newResponseEl.appendChild(newResponseTextEl);

            // Temporary status message to indicate that Khoj is thinking
            let loadingEllipsis = document.createElement("div");
            loadingEllipsis.classList.add("lds-ellipsis");

            let firstEllipsis = document.createElement("div");
            firstEllipsis.classList.add("lds-ellipsis-item");

            let secondEllipsis = document.createElement("div");
            secondEllipsis.classList.add("lds-ellipsis-item");

            let thirdEllipsis = document.createElement("div");
            thirdEllipsis.classList.add("lds-ellipsis-item");

            let fourthEllipsis = document.createElement("div");
            fourthEllipsis.classList.add("lds-ellipsis-item");

            loadingEllipsis.appendChild(firstEllipsis);
            loadingEllipsis.appendChild(secondEllipsis);
            loadingEllipsis.appendChild(thirdEllipsis);
            loadingEllipsis.appendChild(fourthEllipsis);

            newResponseTextEl.appendChild(loadingEllipsis);
            document.getElementById("chat-body").scrollTop = document.getElementById("chat-body").scrollHeight;

            // Call Khoj chat API
            let response = await fetch(chatApi, { headers });
            let rawResponse = "";
            let references = null;
            const contentType = response.headers.get("content-type");

            if (contentType === "application/json") {
                // Handle JSON response
                try {
                    const responseAsJson = await response.json();
                    if (responseAsJson.image) {
                        // If response has image field, response is a generated image.
                        if (responseAsJson.intentType === "text-to-image") {
                            rawResponse += `![${query}](data:image/png;base64,${responseAsJson.image})`;
                        } else if (responseAsJson.intentType === "text-to-image2") {
                            rawResponse += `![${query}](${responseAsJson.image})`;
                        } else if (responseAsJson.intentType === "text-to-image-v3") {
                            rawResponse += `![${query}](data:image/webp;base64,${responseAsJson.image})`;
                        }
                        const inferredQueries = responseAsJson.inferredQueries?.[0];
                        if (inferredQueries) {
                            rawResponse += `\n\n**Inferred Query**:\n\n${inferredQueries}`;
                        }
                    }
                    if (responseAsJson.context) {
                        const rawReferenceAsJson = responseAsJson.context;
                        references = createReferenceSection(rawReferenceAsJson);
                    }
                    if (responseAsJson.detail) {
                        // If response has detail field, response is an error message.
                        rawResponse += responseAsJson.detail;
                    }
                } catch (error) {
                    // If the chunk is not a JSON object, just display it as is
                    rawResponse += chunk;
                } finally {
                    newResponseTextEl.innerHTML = "";
                    newResponseTextEl.appendChild(formatHTMLMessage(rawResponse));

                    if (references != null) {
                        newResponseTextEl.appendChild(references);
                    }

                    document.getElementById("chat-body").scrollTop = document.getElementById("chat-body").scrollHeight;
                }
            } else {
                // Handle streamed response of type text/event-stream or text/plain
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let references = {};

                readStream();

                function readStream() {
                    reader.read().then(({ done, value }) => {
                        if (done) {
                            // Append any references after all the data has been streamed
                            if (references != {}) {
                                newResponseTextEl.appendChild(createReferenceSection(references));
                            }
                            document.getElementById("chat-body").scrollTop = document.getElementById("chat-body").scrollHeight;
                            return;
                        }

                        // Decode message chunk from stream
                        const chunk = decoder.decode(value, { stream: true });

                        if (chunk.includes("### compiled references:")) {
                            const additionalResponse = chunk.split("### compiled references:")[0];
                            rawResponse += additionalResponse;
                            newResponseTextEl.innerHTML = "";
                            newResponseTextEl.appendChild(formatHTMLMessage(rawResponse));

                            const rawReference = chunk.split("### compiled references:")[1];
                            const rawReferenceAsJson = JSON.parse(rawReference);
                            if (rawReferenceAsJson instanceof Array) {
                                references["notes"] = rawReferenceAsJson;
                            } else if (typeof rawReferenceAsJson === "object" && rawReferenceAsJson !== null) {
                                references["online"] = rawReferenceAsJson;
                            }
                            readStream();
                        } else {
                            // Display response from Khoj
                            if (newResponseTextEl.getElementsByClassName("lds-ellipsis").length > 0) {
                                newResponseTextEl.removeChild(loadingEllipsis);
                            }

                            // If the chunk is not a JSON object, just display it as is
                            rawResponse += chunk;
                            newResponseTextEl.innerHTML = "";
                            newResponseTextEl.appendChild(formatHTMLMessage(rawResponse));

                            readStream();
                        }

                        // Scroll to bottom of chat window as chat response is streamed
                        document.getElementById("chat-body").scrollTop = document.getElementById("chat-body").scrollHeight;
                    });
                }
            }
        }

        function incrementalChat(event) {
            if (!event.shiftKey && event.key === 'Enter') {
                event.preventDefault();
                chat();
            }
        }

        function fillCommandInPrompt(command) {
            let chatTooltip = document.getElementById("chat-tooltip");
            chatTooltip.style.display = "none";

            let chatInput = document.getElementById("chat-input");
            chatInput.value = "/" + command + " ";
            chatInput.classList.add("option-enabled");
            chatInput.focus();
        }

        function onChatInput() {
            let chatInput = document.getElementById("chat-input");
            chatInput.value = chatInput.value.trimStart();

            let questionStarterSuggestions = document.getElementById("question-starters");
            questionStarterSuggestions.innerHTML = "";
            questionStarterSuggestions.style.display = "none";

            if (chatInput.value.startsWith("/") && chatInput.value.split(" ").length === 1) {
                let chatTooltip = document.getElementById("chat-tooltip");
                chatTooltip.style.display = "block";
                let helpText = "<div>";
                const command = chatInput.value.split(" ")[0].substring(1);
                for (let key in chatOptions) {
                    if (!!!command || key.startsWith(command)) {
                        helpText += `<div class="helpoption" onclick="fillCommandInPrompt('${key}')"><b>/${key}</b>: ${chatOptions[key]}</div>`;
                    }
                }
                chatTooltip.innerHTML = helpText;
            } else if (chatInput.value.startsWith("/")) {
                const firstWord = chatInput.value.split(" ")[0];
                if (firstWord.substring(1) in chatOptions) {
                    chatInput.classList.add("option-enabled");
                } else {
                    chatInput.classList.remove("option-enabled");
                }
                let chatTooltip = document.getElementById("chat-tooltip");
                chatTooltip.style.display = "none";
            } else {
                let chatTooltip = document.getElementById("chat-tooltip");
                chatTooltip.style.display = "none";
                chatInput.classList.remove("option-enabled");
            }

            autoResize();
        }

        function autoResize() {
            //move scroll of body to bottom of chat-body div
            var chatBody = document.getElementById("chat-body");
            var body = document.body;

            // Calculate the difference between the scroll height and client height of the chat-body
            var scrollDifference = chatBody.scrollHeight - chatBody.clientHeight;

            // Set the scrollTop of the body to the scroll difference
            body.scrollTop = scrollDifference;

            console.log("resize");
        }


        async function getChatHistoryUrl() {
            const hostURL = await window.hostURLAPI.getURL();
            const khojToken = await window.tokenAPI.getToken();
            const headers = { 'Authorization': `Bearer ${khojToken}` };

            let chatBody = document.getElementById("chat-body");
            chatBody.innerHTML = "";
            let chatHistoryUrl = `${hostURL}/api/chat/history?client=desktop`;
            if (chatBody.dataset.conversationId) {
                chatHistoryUrl += `&conversation_id=${chatBody.dataset.conversationId}`;
            }
            return { chatHistoryUrl, headers };
        }

        async function loadChat() {
            // Load chat history and body
            const hostURL = await window.hostURLAPI.getURL();
            const { chatHistoryUrl, headers } = await getChatHistoryUrl();

            // Create loading screen and add it to chat-body
            let loadingScreen = document.createElement('div');
            loadingScreen.classList.add("loading-spinner");
            let yellowOrb = document.createElement('div');
            loadingScreen.appendChild(yellowOrb);
            let chatBody = document.getElementById("chat-body");
            chatBody.appendChild(loadingScreen);

            // Get the most recent 10 chat messages from conversation history
            let firstRunSetupMessageRendered = false;
            fetch(`${chatHistoryUrl}&n=10`, { headers })
                .then(response => response.json())
                .then(data => {
                    if (data.detail) {
                        // If the server returns a 500 error with detail, render a setup hint.
                        renderFirstRunSetupMessage();
                        firstRunSetupMessageRendered = true;
                    } else if (data.status != "ok") {
                        throw new Error(data.message);
                    } else {
                        // Set welcome message on load
                        renderMessage("Hey 👋🏾, what's up?", "khoj");
                    }
                    return data.response;
                })
                .then(response => {
                    let chatBody = document.getElementById("chat-body");
                    chatBody.dataset.conversationId = response.conversation_id;
                    chatBody.dataset.conversationTitle = response.slug || `New conversation 🌱`;

                    // Create a new IntersectionObserver
                    let fetchRemainingMessagesObserver = new IntersectionObserver((entries, observer) => {
                        entries.forEach(entry => {
                            // If the element is in the viewport, fetch the remaining message and unobserve the element
                            if (entry.isIntersecting) {
                                fetchRemainingChatMessages(chatHistoryUrl, headers);
                                observer.unobserve(entry.target);
                            }
                        });
                    }, {rootMargin: '0px 0px 0px 0px'});

                    const fullChatLog = response.chat || [];
                    fullChatLog.forEach((chat_log, index) => {
                        if (chat_log.message != null) {
                            let messageElement = renderMessageWithReference(
                                chat_log.message,
                                chat_log.by,
                                chat_log.context,
                                new Date(chat_log.created),
                                chat_log.onlineContext,
                                chat_log.intent?.type,
                                chat_log.intent?.["inferred-queries"]);
                            chatBody.appendChild(messageElement);

                            // When the 4th oldest message is within viewing distance (~60% scrolled up)
                            // Fetch the remaining chat messages
                            if (index === 4) {
                                fetchRemainingMessagesObserver.observe(messageElement);
                            }
                        }
                        loadingScreen.style.height = chatBody.scrollHeight + 'px';
                    })

                    // Scroll to bottom of chat-body element
                    chatBody.scrollTop = chatBody.scrollHeight;

                    // Set height of chat-body element to the height of the chat-body-wrapper
                    let chatBodyWrapper = document.getElementById("chat-body");
                    let chatBodyWrapperHeight = chatBodyWrapper.clientHeight;
                    chatBody.style.height = chatBodyWrapperHeight;

                    // Add fade out animation to loading screen and remove it after the animation ends
                    fadeOutLoadingAnimation(loadingScreen);
                })
                .catch(err => {
                    // If the server returns a 500 error with detail, render a setup hint.
                    if (!firstRunSetupMessageRendered) {
                        renderFirstRunSetupMessage();
                    }
                    fadeOutLoadingAnimation(loadingScreen);
                    return;
                });

            await refreshChatSessionsPanel();

            fetch(`${hostURL}/api/chat/starters?client=desktop`, { headers })
                .then(response => response.json())
                .then(data => {
                    // Render conversation starters, if any
                    if (data.length > 0) {
                        let questionStarterSuggestions = document.getElementById("question-starters");
                        questionStarterSuggestions.innerHTML = "";
                        data.forEach((questionStarter) => {
                            let questionStarterButton = document.createElement('button');
                            questionStarterButton.innerHTML = questionStarter;
                            questionStarterButton.classList.add("question-starter");
                            questionStarterButton.addEventListener('click', function() {
                                questionStarterSuggestions.style.display = "none";
                                document.getElementById("chat-input").value = questionStarter;
                                chat();
                            });
                            questionStarterSuggestions.appendChild(questionStarterButton);
                        });
                        questionStarterSuggestions.style.display = "grid";
                    }
                })
                .catch(err => {
                    return;
                });

            fetch(`${hostURL}/api/chat/options`, { headers })
                .then(response => response.json())
                .then(data => {
                    // Render chat options, if any
                    if (data) {
                        chatOptions = data;
                    }
                })
                .catch(err => {
                    return;
                });

            // Fill query field with value passed in URL query parameters, if any.
            var query_via_url = new URLSearchParams(window.location.search).get("q");
            if (query_via_url) {
                document.getElementById("chat-input").value = query_via_url;
                chat();
            }
        }

        function fetchRemainingChatMessages(chatHistoryUrl, headers) {
            // Create a new IntersectionObserver
            let observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    // If the element is in the viewport, render the message and unobserve the element
                    if (entry.isIntersecting) {
                        let chat_log = entry.target.chat_log;
                        let messageElement = renderMessageWithReference(
                            chat_log.message,
                            chat_log.by,
                            chat_log.context,
                            new Date(chat_log.created),
                            chat_log.onlineContext,
                            chat_log.intent?.type,
                            chat_log.intent?.["inferred-queries"]
                        );
                        entry.target.replaceWith(messageElement);

                        // Remove the observer after the element has been rendered
                        observer.unobserve(entry.target);
                    }
                });
            }, {rootMargin: '0px 0px 200px 0px'});  // Trigger when the element is within 200px of the viewport

            // Fetch remaining chat messages from conversation history
            fetch(`${chatHistoryUrl}&n=-10`, { headers })
                .then(response => response.json())
                .then(data => {
                    if (data.status != "ok") {
                        throw new Error(data.message);
                    }
                    return data.response;
                })
                .then(response => {
                    const fullChatLog = response.chat || [];
                    let chatBody = document.getElementById("chat-body");
                    fullChatLog
                    .reverse()
                    .forEach(chat_log => {
                        if (chat_log.message != null) {
                            // Create a new element for each chat log
                            let placeholder = document.createElement('div');
                            placeholder.chat_log = chat_log;

                            // Insert the message placeholder as the first child of chat body after the welcome message
                            chatBody.insertBefore(placeholder, chatBody.firstChild.nextSibling);

                            // Observe the element
                            placeholder.style.height = "20px";
                            observer.observe(placeholder);
                        }
                    });
                })
                .catch(err => {
                    console.log(err);
                    return;
                });
        }

        function fadeOutLoadingAnimation(loadingScreen) {
            let chatBody = document.getElementById("chat-body");
            let chatBodyWrapper = document.getElementById("chat-body");
            chatBodyWrapperHeight = chatBodyWrapper.clientHeight;
            chatBody.style.height = chatBodyWrapperHeight;
            setTimeout(() => {
                loadingScreen.remove();
                chatBody.classList.remove("relative-position");
            }, 500);
        }

        function renderFirstRunSetupMessage() {
            first_run_message = `<p class="first-run-message-heading">Hi 👋🏾, to get started:<p>
            <ol>
                <li class="first-run-message-text">Generate an API token <a class='first-run-message-link' href="#" onclick="window.navigateAPI.navigateToWebSettings()">Khoj Web settings</a></li>
                <li class="first-run-message-text">Paste it into the API Key field <a class='first-run-message-link' href="#" onclick="window.navigateAPI.navigateToSettings()">Khoj Desktop settings</a></li>
            </ol>`
            .trim()
            .replace(/(\r\n|\n|\r)/gm, "");

            renderMessage(first_run_message, "khoj", null, null, true);

            // Disable chat input field and update placeholder text
            document.getElementById("chat-input").setAttribute("disabled", "disabled");
            document.getElementById("chat-input").setAttribute("placeholder", "Configure Khoj to enable chat");
        }

        function flashStatusInChatInput(message) {
            // Get chat input element and original placeholder
            let chatInput = document.getElementById("chat-input");
            let originalPlaceholder = chatInput.placeholder;
            // Set placeholder to message
            chatInput.placeholder = message;
            // Reset placeholder after 2 seconds
            setTimeout(() => {
                chatInput.placeholder = originalPlaceholder;
            }, 2000);
        }

        function createNewConversation() {
            let chatBody = document.getElementById("chat-body");
            chatBody.innerHTML = "";
            flashStatusInChatInput("📝 New conversation started");
            chatBody.dataset.conversationId = "";
            chatBody.dataset.conversationTitle = "";
            renderMessage("Hey 👋🏾, what's up?", "khoj");
        }

        async function clearConversationHistory() {
            let chatInput = document.getElementById("chat-input");
            let originalPlaceholder = chatInput.placeholder;
            let chatBody = document.getElementById("chat-body");
            let conversationId = chatBody.dataset.conversationId;

            let deleteURL = `/api/chat/history?client=desktop`;
            if (conversationId) {
                deleteURL += `&conversation_id=${conversationId}`;
            }

            const hostURL = await window.hostURLAPI.getURL();
            const khojToken = await window.tokenAPI.getToken();
            const headers = { 'Authorization': `Bearer ${khojToken}` };

            fetch(`${hostURL}${deleteURL}`, { method: "DELETE", headers })
                .then(response => response.ok ? response.json() : Promise.reject(response))
                .then(data => {
                    chatBody.innerHTML = "";
                    chatBody.dataset.conversationId = "";
                    chatBody.dataset.conversationTitle = "";
                    loadChat();
                })
                .catch(err => {
                    flashStatusInChatInput("⛔️ Failed to clear conversation history");
                })
        }

        async function refreshChatSessionsPanel() {
            const hostURL = await window.hostURLAPI.getURL();
            const khojToken = await window.tokenAPI.getToken();
            const headers = { 'Authorization': `Bearer ${khojToken}` };

            fetch(`${hostURL}/api/chat/sessions`, { method: "GET", headers })
                .then(response => response.json())
                .then(data => {
                    let conversationListBody = document.getElementById("conversation-list-body");
                    conversationListBody.innerHTML = "";
                    let conversationListBodyHeader = document.getElementById("conversation-list-header");

                    let chatBody = document.getElementById("chat-body");
                    conversationId = chatBody.dataset.conversationId;

                    if (data.length > 0) {
                        conversationListBodyHeader.style.display = "block";
                        for (let index in data) {
                            let conversation = data[index];
                            let conversationButton = document.createElement('div');
                            let incomingConversationId = conversation["conversation_id"];
                            const conversationTitle = conversation["slug"] || `New conversation 🌱`;
                            conversationButton.textContent = conversationTitle;
                            conversationButton.classList.add("conversation-button");
                            if (incomingConversationId == conversationId) {
                                conversationButton.classList.add("selected-conversation");
                            }
                            conversationButton.addEventListener('click', function() {
                                let chatBody = document.getElementById("chat-body");
                                chatBody.innerHTML = "";
                                chatBody.dataset.conversationId = incomingConversationId;
                                chatBody.dataset.conversationTitle = conversationTitle;
                                loadChat();
                            });
                            let threeDotMenu = document.createElement('div');
                            threeDotMenu.classList.add("three-dot-menu");
                            let threeDotMenuButton = document.createElement('button');
                            threeDotMenuButton.innerHTML = "⋮";
                            threeDotMenuButton.classList.add("three-dot-menu-button");
                            threeDotMenuButton.addEventListener('click', function(event) {
                                event.stopPropagation();

                                let existingChildren = threeDotMenu.children;

                                if (existingChildren.length > 1) {
                                    // Skip deleting the first, since that's the menu button.
                                    for (let i = 1; i < existingChildren.length; i++) {
                                        existingChildren[i].remove();
                                    }
                                    return;
                                }

                                let conversationMenu = document.createElement('div');
                                conversationMenu.classList.add("conversation-menu");

                                let editTitleButton = document.createElement('button');
                                editTitleButton.innerHTML = "Rename";
                                editTitleButton.classList.add("edit-title-button");
                                editTitleButton.classList.add("three-dot-menu-button-item");
                                editTitleButton.addEventListener('click', function(event) {
                                    event.stopPropagation();

                                    let conversationMenuChildren = conversationMenu.children;

                                    let totalItems = conversationMenuChildren.length;

                                    for (let i = totalItems - 1; i >= 0; i--) {
                                        conversationMenuChildren[i].remove();
                                    }

                                    // Create a dialog box to get new title for conversation
                                    let conversationTitleInputBox = document.createElement('div');
                                    conversationTitleInputBox.classList.add("conversation-title-input-box");
                                    let conversationTitleInput = document.createElement('input');
                                    conversationTitleInput.classList.add("conversation-title-input");

                                    conversationTitleInput.value = conversationTitle;

                                    conversationTitleInput.addEventListener('click', function(event) {
                                        event.stopPropagation();
                                    });
                                    conversationTitleInput.addEventListener('keydown', function(event) {
                                        if (event.key === "Enter") {
                                            event.preventDefault();
                                            conversationTitleInputButton.click();
                                        }
                                    });
                                    conversationTitleInputBox.appendChild(conversationTitleInput);
                                    let conversationTitleInputButton = document.createElement('button');
                                    conversationTitleInputButton.innerHTML = "Save";
                                    conversationTitleInputButton.classList.add("three-dot-menu-button-item");
                                    conversationTitleInputButton.addEventListener('click', function(event) {
                                        event.stopPropagation();
                                        let newTitle = conversationTitleInput.value;
                                        if (newTitle != null) {
                                            let editURL = `/api/chat/title?client=web&conversation_id=${incomingConversationId}&title=${newTitle}`;
                                            fetch(`${hostURL}${editURL}` , { method: "PATCH", headers })
                                                .then(response => response.ok ? response.json() : Promise.reject(response))
                                                .then(data => {
                                                    conversationButton.textContent = newTitle;
                                                })
                                                .catch(err => {
                                                    return;
                                                });
                                        conversationTitleInputBox.remove();
                                    }});
                                    conversationTitleInputBox.appendChild(conversationTitleInputButton);
                                    conversationMenu.appendChild(conversationTitleInputBox);
                                });

                                conversationMenu.appendChild(editTitleButton);
                                threeDotMenu.appendChild(conversationMenu);

                                let deleteButton = document.createElement('button');
                                deleteButton.type = "button";
                                deleteButton.innerHTML = "Delete";
                                deleteButton.classList.add("delete-conversation-button");
                                deleteButton.classList.add("three-dot-menu-button-item");
                                deleteButton.addEventListener('click', function(event) {
                                    event.preventDefault();
                                    let confirmation = confirm('Are you sure you want to delete this chat session?');
                                    if (!confirmation) return;
                                    let deleteURL = `/api/chat/history?client=web&conversation_id=${incomingConversationId}`;
                                    fetch(`${hostURL}${deleteURL}` , { method: "DELETE", headers })
                                        .then(response => response.ok ? response.json() : Promise.reject(response))
                                        .then(data => {
                                            let chatBody = document.getElementById("chat-body");
                                            chatBody.innerHTML = "";
                                            chatBody.dataset.conversationId = "";
                                            chatBody.dataset.conversationTitle = "";
                                            loadChat();
                                        })
                                        .catch(err => {
                                            return;
                                        });
                                });

                                conversationMenu.appendChild(deleteButton);
                                threeDotMenu.appendChild(conversationMenu);
                            });
                            threeDotMenu.appendChild(threeDotMenuButton);
                            conversationButton.appendChild(threeDotMenu);
                            conversationListBody.appendChild(conversationButton);
                        }
                    }
                }).catch(err => {
                    return;
            });
        }

        let sendMessageTimeout;
        let mediaRecorder;
        async function speechToText(event) {
            event.preventDefault();
            const speakButtonImg = document.getElementById('speak-button-img');
            const stopRecordButtonImg = document.getElementById('stop-record-button-img');
            const sendButtonImg = document.getElementById('send-button-img');
            const stopSendButtonImg = document.getElementById('stop-send-button-img');
            const chatInput = document.getElementById('chat-input');

            const hostURL = await window.hostURLAPI.getURL();
            let url = `${hostURL}/api/transcribe?client=desktop`;
            const khojToken = await window.tokenAPI.getToken();
            const headers = { 'Authorization': `Bearer ${khojToken}` };

            const sendToServer = (audioBlob) => {
                const formData = new FormData();
                formData.append('file', audioBlob);

                fetch(url, { method: 'POST', body: formData, headers})
                    .then(response => response.ok ? response.json() : Promise.reject(response))
                    .then(data => { chatInput.value += data.text.trimStart(); autoResize(); })
                    .then(() => {
                        // Don't auto-send empty messages
                        if (chatInput.value.length === 0) return;

                        // Send message after 3 seconds, unless stop send button is clicked
                        sendButtonImg.style.display = 'none';
                        stopSendButtonImg.style.display = 'initial';

                        // Start the countdown timer UI
                        document.getElementById('countdown-circle').style.animation = "countdown 3s linear 1 forwards";

                        sendMessageTimeout = setTimeout(() => {
                            // Revert to showing send-button and hide the stop-send-button
                            sendButtonImg.style.display = 'initial';
                            stopSendButtonImg.style.display = 'none';

                            // Stop the countdown timer UI
                            document.getElementById('countdown-circle').style.animation = "none";

                            // Send message
                            chat();
                        }, 3000);
                    })
                    .catch(err => {
                        if (err.status === 501) {
                          flashStatusInChatInput("⛔️ Configure speech-to-text model on server.")
                        } else if (err.status === 422) {
                          flashStatusInChatInput("⛔️ Audio file to large to process.")
                        } else {
                          flashStatusInChatInput("⛔️ Failed to transcribe audio.")
                        }
                    });
            };

            const handleRecording = (stream) => {
                const audioChunks = [];
                const recordingConfig = { mimeType: 'audio/webm' };
                mediaRecorder = new MediaRecorder(stream, recordingConfig);

                mediaRecorder.addEventListener("dataavailable", function(event) {
                    if (event.data.size > 0) audioChunks.push(event.data);
                });

                mediaRecorder.addEventListener("stop", function() {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    sendToServer(audioBlob);
                });

                mediaRecorder.start();
                speakButtonImg.style.display = 'none';
                stopRecordButtonImg.style.display = 'initial';
            };

            // Toggle recording
            if (!mediaRecorder || mediaRecorder.state === 'inactive' || event.type === 'touchstart') {
                navigator.mediaDevices
                ?.getUserMedia({ audio: true })
                .then(handleRecording)
                .catch((e) => {
                    flashStatusInChatInput("⛔️ Failed to access microphone");
                });
            } else if (mediaRecorder.state === 'recording' || event.type === 'touchend' || event.type === 'touchcancel') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                mediaRecorder = null;
                speakButtonImg.style.display = 'initial';
                stopRecordButtonImg.style.display = 'none';
            }
        }

        function cancelSendMessage() {
            // Cancel the chat() call if the stop-send-button is clicked
            clearTimeout(sendMessageTimeout);

            // Revert to showing send-button and hide the stop-send-button
            document.getElementById('stop-send-button-img').style.display = 'none';
            document.getElementById('send-button-img').style.display = 'initial';

            // Stop the countdown timer UI
            document.getElementById('countdown-circle').style.animation = "none";
        };

        function handleCollapseSidePanel() {
            document.getElementById('side-panel').classList.toggle('collapsed');
            document.getElementById('new-conversation').classList.toggle('collapsed');
            document.getElementById('existing-conversations').classList.toggle('collapsed');
            document.getElementById('side-panel-collapse').style.transform = document.getElementById('side-panel').classList.contains('collapsed') ? 'rotate(0deg)' : 'rotate(180deg)';
        }
    </script>
</body>
</html>
